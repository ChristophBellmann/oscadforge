from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Sequence

from ..papierkorb.layout import PanelPlacement
from ..papierkorb.panels import AxisDirection, Panel, PanelFeature
from .connectors import ConnectorPlan
from .panels import OpenGridPanelSet
from .params import BoardOptions, ConnectorOptions


PALETTE = [
    (0.88, 0.40, 0.36),
    (0.25, 0.55, 0.78),
    (0.32, 0.70, 0.48),
    (0.85, 0.65, 0.25),
    (0.60, 0.45, 0.80),
    (0.90, 0.55, 0.75),
    (0.40, 0.75, 0.85),
    (0.55, 0.65, 0.30),
    (0.75, 0.35, 0.60),
    (0.30, 0.60, 0.55),
    (0.85, 0.45, 0.30),
    (0.40, 0.50, 0.80),
]


@dataclass
class IncludePaths:
    bosl2: str
    open_grid: str
    snap: str
    angle_connector: str


def build_scad_for_artifact(
    *,
    artifact_label: str,
    placements: Iterable[PanelPlacement],
    panel_set: OpenGridPanelSet,
    board: BoardOptions,
    connectors: ConnectorPlan | None,
    connector_opts: ConnectorOptions | None,
    includes: IncludePaths,
    include_preview_imports: bool = True,
) -> str:
    header = _build_header(includes, board)
    if artifact_label == "connectors":
        body = _connectors_body(connectors, board, connector_opts, includes.angle_connector)
        return f"{header}\n{body}\nconnectors_artifact();\n"
    panel_modules = _panel_modules(panel_set, board)
    placement_block = _placement_block(
        artifact_label,
        placements,
        board.tile_size_mm,
        board,
        panel_set,
        include_preview_imports=include_preview_imports,
    )
    return f"{header}\n{panel_modules}\n{placement_block}\nartifact_{artifact_label}();\n"


def build_scad_for_panel(
    *,
    panel: Panel,
    board: BoardOptions,
    includes: IncludePaths,
) -> str:
    header = _build_header(includes, board)
    module = _panel_module(panel, board)
    return f"{header}\n{module}\npanel_geom_{panel.panel_id}();\n"


def _build_header(includes: IncludePaths, board: BoardOptions) -> str:
    bool_val = lambda val: "true" if val else "false"
    variant = board.variant.strip()
    chamfers = board.chamfers.strip()
    screw = board.screw_mounting.strip()
    return (
        f"// Generated by oscadforge opengrid-beam_papierkorb backend\n"
        f'include <{includes.bosl2}>;\n'
        f'use <{includes.open_grid}>;\n'
        f'use <{includes.snap}>;\n'
        f'Full_or_Lite = "{variant}";\n'
        f'Chamfers = "{chamfers}";\n'
        f'Screw_Mounting = "{screw}";\n'
        f"Connector_Holes = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Bottom = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Top = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Left = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Right = {bool_val(board.connector_holes)};\n"
    )


def _panel_modules(panel_set: OpenGridPanelSet, board: BoardOptions) -> str:
    modules = []
    for panel in panel_set.panels:
        modules.append(_panel_module(panel, board))
    return "\n".join(modules)


def _panel_module(panel: Panel, board: BoardOptions) -> str:
    cells_u = max(1, int(round(panel.width / board.tile_size_mm)))
    cells_v = max(1, int(round(panel.height / board.tile_size_mm)))
    thickness = board.thickness_mm
    call = _board_call(cells_u, cells_v, thickness, board)
    return f"module panel_geom_{panel.panel_id}() {{\n    {call}\n}}\n"


def _board_call(cells_u: int, cells_v: int, thickness: float, board: BoardOptions) -> str:
    bool_val = lambda val: "true" if val else "false"
    base_args = (
        f"Board_Width={cells_u}, "
        f"Board_Height={cells_v}, "
        f"tileSize={board.tile_size_mm:.4f}, "
        f'Screw_Mounting="{board.screw_mounting}", '
        f'Chamfers="{board.chamfers}", '
        f"Connector_Holes={bool_val(board.connector_holes)}"
    )
    if board.variant.strip().lower() == "lite":
        return f"openGridLite({base_args}, Add_Adhesive_Base={bool_val(board.adhesive_base)}, anchor=CENTER);"
    if board.variant.strip().lower() == "heavy":
        return f"openGridHeavy({base_args}, anchor=CENTER);"
    return f"openGrid({base_args}, Tile_Thickness={thickness:.4f}, anchor=CENTER);"


def _placement_block(
    label: str,
    placements: Iterable[PanelPlacement],
    tile_size: float,
    board: BoardOptions,
    panel_set: OpenGridPanelSet,
    include_preview_imports: bool = True,
) -> str:
    statements = []
    for placement in placements:
        matrix = placement_matrix(placement)
        transform = _format_matrix(matrix)
        colour = _panel_colour(placement.panel.panel_id)
        statements.append(f"    {colour} multmatrix({transform}) panel_geom_{placement.panel.panel_id}();")
    body = "\n".join(statements) if statements else "    // no panels"
    accessories = _imported_angle_connectors(board, panel_set, label, include_preview_imports)
    return f"module artifact_{label}() {{\n  union() {{\n{body}{accessories}\n  }}\n}}\n"


def placement_matrix(placement: PanelPlacement) -> list[list[float]]:
    origin = placement.origin
    u_vec = placement.axes.u.vector()
    v_vec = placement.axes.v.vector()
    w_vec = placement.axes.w.vector()
    return [
        [u_vec.x, v_vec.x, w_vec.x, origin.x],
        [u_vec.y, v_vec.y, w_vec.y, origin.y],
        [u_vec.z, v_vec.z, w_vec.z, origin.z],
        [0.0, 0.0, 0.0, 1.0],
    ]


def _format_matrix(matrix: Sequence[Sequence[float]]) -> str:
    rows = ["[{}]".format(", ".join(f"{value:.6f}" for value in row)) for row in matrix]
    return f"[{', '.join(rows)}]"


def _panel_colour(panel_id: str) -> str:
    seed = sum(panel_id.encode("utf-8"))
    r, g, b = PALETTE[seed % len(PALETTE)]
    return f"color([{r:.3f}, {g:.3f}, {b:.3f}])"


def _connectors_body(
    plan: ConnectorPlan | None,
    board: BoardOptions,
    connector_opts: ConnectorOptions | None,
    angle_connector_path: str,
) -> str:
    if plan is None:
        plan = ConnectorPlan(snap_count=0, corner_count=0)
    if connector_opts is None:
        connector_opts = ConnectorOptions()
    spacing = board.tile_size_mm + 6.0
    per_row = 8
    snap_lines = _replicated_snap_block(plan.snap_count, spacing, per_row, connector_opts)
    corner_module, corner_lines = _replicated_corner_block(
        plan.corner_count,
        spacing,
        per_row,
        plan.snap_count,
        board,
        angle_connector_path,
    )
    header = corner_module if corner_module else ""
    return (
        f"{header}"
        "module connectors_artifact() {\n"
        "  union() {\n"
        f"{snap_lines}\n"
        f"{corner_lines}\n"
        "  }\n"
        "}\n"
    )


def _replicated_snap_block(count: int, spacing: float, per_row: int, connector_opts: ConnectorOptions) -> str:
    if count <= 0:
        return "    // no snap connectors requested"
    bool_val = lambda val: "true" if val else "false"
    lite_mode = connector_opts.snap_variant.strip().lower() != "full"
    lines = []
    for idx in range(count):
        row = idx // per_row
        col = idx % per_row
        x = col * spacing
        y = row * spacing
        lines.append(
            f"    translate([{x:.3f}, {y:.3f}, 0]) openGridSnap(lite={bool_val(lite_mode)}, directional={bool_val(connector_opts.directional_snaps)}, orient=UP, anchor=CENTER, spin=0);"
        )
    return "\n".join(lines)


def _replicated_corner_block(
    count: int,
    spacing: float,
    per_row: int,
    snap_total: int,
    board: BoardOptions,
    angle_connector_path: str,
) -> tuple[str, str]:
    if count <= 0:
        return "", "    // no right-angle connectors requested"
    rows_of_snaps = (snap_total + per_row - 1) // per_row
    base_y = rows_of_snaps * spacing + spacing
    module_lines = [
        "module og_corner_connector() {",
        f"  import(\"{angle_connector_path}\");",
        "}\n",
    ]
    lines: list[str] = []
    for idx in range(count):
        row = idx // per_row
        col = idx % per_row
        x = col * spacing
        y = base_y + row * spacing
        lines.append(f"    translate([{x:.3f}, {y:.3f}, 0]) og_corner_connector();")
    return "\n".join(module_lines), "\n".join(lines)


def _imported_angle_connectors(
    board: BoardOptions, panel_set: OpenGridPanelSet, label: str, include_preview_imports: bool
) -> str:
    # Disabled for now – the OpenGrid angle STL breaks OpenSCAD's CSG export and slows down STEP conversion.
    return "\n"
    if label != "assembled" or not include_preview_imports:
        return "\n"
    length = panel_set.length_mm
    width = panel_set.width_mm
    height = panel_set.height_mm + board.thickness_mm
    entries = []
    stl_path = board.angle_connector_path if hasattr(board, "angle_connector_path") else ""
    if not stl_path:
        return "\n"
    # Long sides (±X), connectors centered, pointing inward
    entries.append(
        f"\n    translate([0, {width/2 + board.thickness_mm:.3f}, {height:.3f}]) rotate([0,180,0]) import(\"{stl_path}\");"
    )
    entries.append(
        f"\n    translate([0, {-width/2 - board.thickness_mm:.3f}, {height:.3f}]) rotate([180,0,180]) import(\"{stl_path}\");"
    )
    # Short sides (±Y)
    entries.append(
        f"\n    translate([{length/2 + board.thickness_mm:.3f}, 0, {height:.3f}]) rotate([0,180,90]) import(\"{stl_path}\");"
    )
    entries.append(
        f"\n    translate([{-length/2 - board.thickness_mm:.3f}, 0, {height:.3f}]) rotate([180,0,90]) import(\"{stl_path}\");"
    )
    return "\n" + "".join(entries) + "\n"
