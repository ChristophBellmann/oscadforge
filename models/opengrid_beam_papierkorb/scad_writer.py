from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
import colorsys
import re
from typing import Iterable, Mapping, Sequence

from ..papierkorb.layout import PanelPlacement
from ..papierkorb.panels import AxisDirection, Panel, PanelFeature, PanelKind
from .connectors import ConnectorPlan
from .panels import OpenGridPanelSet
from .params import BoardOptions, ConnectorOptions


PALETTE = [
    (0.88, 0.40, 0.36),
    (0.25, 0.55, 0.78),
    (0.32, 0.70, 0.48),
    (0.85, 0.65, 0.25),
    (0.60, 0.45, 0.80),
    (0.90, 0.55, 0.75),
    (0.40, 0.75, 0.85),
    (0.55, 0.65, 0.30),
    (0.75, 0.35, 0.60),
    (0.30, 0.60, 0.55),
    (0.85, 0.45, 0.30),
    (0.40, 0.50, 0.80),
]


@dataclass
class IncludePaths:
    bosl2: str
    open_grid: str
    open_grid_beam: str
    snap: str
    angle_connector: str


class BeamPlacementMode(Enum):
    PANEL_ONLY = "panel"
    BEAM_ONLY = "beam"
    BOTH = "both"


@dataclass(frozen=True)
class BeamCallConfig:
    enable_beam_sides: bool = True
    enable_chamfers: bool = True
    enable_joints: bool = True


def build_scad_for_artifact(
    *,
    artifact_label: str,
    placements: Iterable[PanelPlacement],
    panel_set: OpenGridPanelSet,
    board: BoardOptions,
    connectors: ConnectorPlan | None,
    connector_opts: ConnectorOptions | None,
    includes: IncludePaths,
    include_preview_imports: bool = True,
    beam_mode: BeamPlacementMode = BeamPlacementMode.PANEL_ONLY,
) -> str:
    header = _build_header(includes, board)
    if artifact_label == "connectors":
        body = _connectors_body(connectors, board, connector_opts, includes.angle_connector)
        return f"{header}\n{body}\nconnectors_artifact();\n"
    panel_modules = _panel_modules(panel_set, board)
    color_defs, color_map = _build_panel_color_modules(panel_set)
    placement_block = _placement_block(
        artifact_label,
        placements,
        board.tile_size_mm,
        board,
        panel_set,
        include_preview_imports=include_preview_imports,
        beam_mode=beam_mode,
        color_map=color_map,
    )
    sections = [header]
    if panel_modules:
        sections.append(panel_modules)
    if color_defs:
        sections.append(color_defs)
    sections.append(placement_block)
    sections.append(f"artifact_{artifact_label}();")
    return "\n\n".join(sections) + "\n"


def build_scad_for_panel(
    *,
    panel: Panel,
    board: BoardOptions,
    includes: IncludePaths,
) -> str:
    header = _build_header(includes, board)
    module = _panel_module(panel, board)
    return f"{header}\n{module}\npanel_geom_{panel.panel_id}();\n"


def _build_header(includes: IncludePaths, board: BoardOptions) -> str:
    bool_val = lambda val: "true" if val else "false"
    variant = board.variant.strip()
    chamfers = board.chamfers.strip()
    screw = board.screw_mounting.strip()
    return (
        f"// Generated by oscadforge opengrid-beam_papierkorb backend\n"
        f'include <{includes.bosl2}>;\n'
        f'use <{includes.open_grid}>;\n'
        f'use <{includes.open_grid_beam}>;\n'
        f'use <{includes.snap}>;\n'
        f'Full_or_Lite = "{variant}";\n'
        f'Chamfers = "{chamfers}";\n'
        f'Screw_Mounting = "{screw}";\n'
        f"Connector_Holes = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Bottom = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Top = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Left = {bool_val(board.connector_holes)};\n"
        f"Connector_Holes_Right = {bool_val(board.connector_holes)};\n"
        "Boardconnector_Bottom_l = true;\n"
        "Boardconnector_Bottom_r = true;\n"
        "Boardconnector_Left_l = true;\n"
        "Boardconnector_Left_r = true;\n"
        "Boardconnector_Top_l = true;\n"
        "Boardconnector_Top_r = true;\n"
        "Boardconnector_Right_l = true;\n"
        "Boardconnector_Right_r = true;\n"
    )


def _panel_modules(panel_set: OpenGridPanelSet, board: BoardOptions) -> str:
    modules = []
    central_ids = _central_floor_panel_ids(panel_set)
    for panel in panel_set.panels:
        modules.append(_panel_module(panel, board))
        config = _beam_config_for_panel(panel, central_ids)
        modules.append(_beam_module(panel, board, config))
    return "\n".join(modules)


def _panel_module(panel: Panel, board: BoardOptions) -> str:
    cells_u = max(1, int(round(panel.width / board.tile_size_mm)))
    cells_v = max(1, int(round(panel.height / board.tile_size_mm)))
    thickness = board.thickness_mm
    call = _board_call(cells_u, cells_v, thickness, board)
    return f"module panel_geom_{panel.panel_id}() {{\n    {call}\n}}\n"


def _beam_module(panel: Panel, board: BoardOptions, config: BeamCallConfig) -> str:
    cells_u = max(1, int(round(panel.width / board.tile_size_mm)))
    cells_v = max(1, int(round(panel.height / board.tile_size_mm)))
    thickness = board.thickness_mm
    call = _beam_call(cells_u, cells_v, thickness, board, config)
    beam_id = _beam_panel_id(panel.panel_id)
    return f"module panel_geom_{beam_id}() {{\n{call}\n}}\n"


def _beam_panel_id(panel_id: str) -> str:
    if "_" in panel_id:
        prefix, rest = panel_id.split("_", 1)
        return f"{prefix}beam_{rest}"
    return f"{panel_id}beam"


def _beam_call(cells_u: int, cells_v: int, thickness: float, board: BoardOptions, config: BeamCallConfig) -> str:
    bool_val = lambda val: "true" if val else "false"
    sides_val = bool_val(config.enable_beam_sides)
    chamfer_val = bool_val(config.enable_chamfers)
    joint_val = bool_val(config.enable_joints)
    lines = [
        "    openGridbeam(",
        f"    Board_Width             = {cells_u},",
        f"    Board_Height            = {cells_v},",
        "",
        "    // Beam-Sides",
        f"    Beam_Bottom             = {sides_val},",
        f"    Beam_Left               = {sides_val},",
        f"    Beam_Top                = {sides_val},",
        f"    Beam_Right              = {sides_val},",
        "",
        "",
        "    // Beam Connector Options",
        "    Beamconnector_Bottom_l  = true,",
        "    Beamconnector_Bottom_r  = true,",
        "    Beamconnector_Left_l    = true,",
        "    Beamconnector_Left_r    = true,",
        "    Beamconnector_Top_l     = true,",
        "    Beamconnector_Top_r     = true,",
        "    Beamconnector_Right_l   = true,",
        "    Beamconnector_Right_r   = true,",
        "",
        "    // Joint Options",
        f"    Joints                  = {joint_val},",
        f"    Joint_Bottom_l          = {joint_val},",
        f"    Joint_Bottom_r          = {joint_val},",
        f"    Joint_Left_l            = {joint_val},",
        f"    Joint_Left_r            = {joint_val},",
        f"    Joint_Top_l             = {joint_val},",
        f"    Joint_Top_r             = {joint_val},",
        f"    Joint_Right_l           = {joint_val},",
        f"    Joint_Right_r           = {joint_val},",
        "",
        "    // Attached Option",
        "    Joint_attached          = false,",
        "",
        "    // Chamfer Options",
        f"    Chamfers                = {chamfer_val},",
        f"    Chamfer_Bottom_l        = {chamfer_val},",
        f"    Chamfer_Bottom_r        = {chamfer_val},",
        f"    Chamfer_Left_l          = {chamfer_val},",
        f"    Chamfer_Left_r          = {chamfer_val},",
        f"    Chamfer_Top_l           = {chamfer_val},",
        f"    Chamfer_Top_r           = {chamfer_val},",
        f"    Chamfer_Right_l         = {chamfer_val},",
        f"    Chamfer_Right_r         = {chamfer_val},",
        "",
        "    // OpenSCAD Transform Parameters",
        "    anchor                  = CENTER,",
        "    spin                    = 0,",
        "    orient                  = UP",
        "    );",
    ]
    return "\n".join(lines)


def _build_panel_color_modules(panel_set: OpenGridPanelSet) -> tuple[str, dict[str, str]]:
    panels = sorted(panel_set.panels, key=lambda panel: panel.panel_id)
    if not panels:
        return "", {}
    modules: list[str] = []
    mapping: dict[str, str] = {}
    total = len(panels)
    for idx, panel in enumerate(panels):
        module_name = f"panel_color_{_sanitize_id(panel.panel_id)}"
        mapping[panel.panel_id] = module_name
        r, g, b = _rainbow_color(idx, total)
        modules.append(
            f"module {module_name}() {{\n"
            f"  color([{r:.3f}, {g:.3f}, {b:.3f}]) children();\n"
            f"}}"
        )
    return "\n\n".join(modules), mapping


def _sanitize_id(value: str) -> str:
    cleaned = re.sub(r"[^A-Za-z0-9_]", "_", value)
    if not cleaned:
        return "panel"
    return cleaned if not cleaned[0].isdigit() else f"_{cleaned}"


def _rainbow_color(index: int, total: int) -> tuple[float, float, float]:
    if total <= 0:
        return 0.5, 0.5, 0.5
    hue = (index / total) % 1.0
    r, g, b = colorsys.hsv_to_rgb(hue, 0.75, 0.95)
    return r, g, b


def _beam_config_for_panel(panel: Panel, central_ids: set[str]) -> BeamCallConfig:
    if panel.panel_id in central_ids:
        return BeamCallConfig(enable_beam_sides=False, enable_chamfers=False, enable_joints=False)
    return BeamCallConfig()


def _central_floor_panel_ids(panel_set: OpenGridPanelSet) -> set[str]:
    lookup: dict[tuple[int, int], str] = {}
    for panel in panel_set.panels:
        if panel.kind is PanelKind.FLOOR:
            ix, iy, _ = panel.indices
            lookup[(ix, iy)] = panel.panel_id
    central: set[str] = set()
    for (ix, iy), panel_id in lookup.items():
        neighbors = [
            (ix - 1, iy),
            (ix + 1, iy),
            (ix, iy - 1),
            (ix, iy + 1),
        ]
        if all(nb in lookup for nb in neighbors):
            central.add(panel_id)
    return central


def _board_call(cells_u: int, cells_v: int, thickness: float, board: BoardOptions) -> str:
    bool_val = lambda val: "true" if val else "false"
    base_args = (
        f"Board_Width={cells_u}, "
        f"Board_Height={cells_v}, "
        f"tileSize={board.tile_size_mm:.4f}, "
        f'Screw_Mounting="{board.screw_mounting}", '
        f'Chamfers="{board.chamfers}", '
        f"Connector_Holes={bool_val(board.connector_holes)}"
    )
    if board.variant.strip().lower() == "lite":
        return f"openGridLite({base_args}, Add_Adhesive_Base={bool_val(board.adhesive_base)}, anchor=CENTER);"
    if board.variant.strip().lower() == "heavy":
        return f"openGridHeavy({base_args}, anchor=CENTER);"
    return f"openGrid({base_args}, Tile_Thickness={thickness:.4f}, anchor=CENTER);"


def _placement_block(
    label: str,
    placements: Iterable[PanelPlacement],
    tile_size: float,
    board: BoardOptions,
    panel_set: OpenGridPanelSet,
    include_preview_imports: bool = True,
    beam_mode: BeamPlacementMode = BeamPlacementMode.PANEL_ONLY,
    color_map: Mapping[str, str] | None = None,
) -> str:
    color_map = color_map or {}
    statements = []
    for placement in placements:
        matrix = placement_matrix(placement)
        transform = _format_matrix(matrix)
        module_names: list[str] = []
        if beam_mode in (BeamPlacementMode.PANEL_ONLY, BeamPlacementMode.BOTH):
            module_names.append(placement.panel.panel_id)
        if beam_mode in (BeamPlacementMode.BEAM_ONLY, BeamPlacementMode.BOTH):
            module_names.append(_beam_panel_id(placement.panel.panel_id))
        for module_id in module_names:
            col_module = color_map.get(placement.panel.panel_id) if color_map else None
            if col_module:
                statements.append(
                    f"    {col_module}() {{\n"
                    f"      multmatrix({transform}) panel_geom_{module_id}();\n"
                    f"    }}"
                )
            else:
                colour = _panel_colour(placement.panel.panel_id)
                statements.append(f"    {colour} multmatrix({transform}) panel_geom_{module_id}();")
    body = "\n".join(statements) if statements else "    // no panels"
    accessories = _imported_angle_connectors(board, panel_set, label, include_preview_imports)
    return f"module artifact_{label}() {{\n  union() {{\n{body}{accessories}\n  }}\n}}\n"


def placement_matrix(placement: PanelPlacement) -> list[list[float]]:
    origin = placement.origin
    u_vec = placement.axes.u.vector()
    v_vec = placement.axes.v.vector()
    w_vec = placement.axes.w.vector()
    return [
        [u_vec.x, v_vec.x, w_vec.x, origin.x],
        [u_vec.y, v_vec.y, w_vec.y, origin.y],
        [u_vec.z, v_vec.z, w_vec.z, origin.z],
        [0.0, 0.0, 0.0, 1.0],
    ]


def _format_matrix(matrix: Sequence[Sequence[float]]) -> str:
    rows = ["[{}]".format(", ".join(f"{value:.6f}" for value in row)) for row in matrix]
    return f"[{', '.join(rows)}]"


def _panel_colour(panel_id: str) -> str:
    seed = sum(panel_id.encode("utf-8"))
    r, g, b = PALETTE[seed % len(PALETTE)]
    return f"color([{r:.3f}, {g:.3f}, {b:.3f}])"


def _connectors_body(
    plan: ConnectorPlan | None,
    board: BoardOptions,
    connector_opts: ConnectorOptions | None,
    angle_connector_path: str,
) -> str:
    if plan is None:
        plan = ConnectorPlan(snap_count=0, corner_count=0)
    if connector_opts is None:
        connector_opts = ConnectorOptions()
    spacing = board.tile_size_mm + 6.0
    per_row = 8
    snap_lines = _replicated_snap_block(plan.snap_count, spacing, per_row, connector_opts)
    corner_module, corner_lines = _replicated_corner_block(
        plan.corner_count,
        spacing,
        per_row,
        plan.snap_count,
        board,
        angle_connector_path,
    )
    header = corner_module if corner_module else ""
    return (
        f"{header}"
        "module connectors_artifact() {\n"
        "  union() {\n"
        f"{snap_lines}\n"
        f"{corner_lines}\n"
        "  }\n"
        "}\n"
    )


def _replicated_snap_block(count: int, spacing: float, per_row: int, connector_opts: ConnectorOptions) -> str:
    if count <= 0:
        return "    // no snap connectors requested"
    bool_val = lambda val: "true" if val else "false"
    lite_mode = connector_opts.snap_variant.strip().lower() != "full"
    lines = []
    for idx in range(count):
        row = idx // per_row
        col = idx % per_row
        x = col * spacing
        y = row * spacing
        lines.append(
            f"    translate([{x:.3f}, {y:.3f}, 0]) openGridSnap(lite={bool_val(lite_mode)}, directional={bool_val(connector_opts.directional_snaps)}, orient=UP, anchor=CENTER, spin=0);"
        )
    return "\n".join(lines)


def _replicated_corner_block(
    count: int,
    spacing: float,
    per_row: int,
    snap_total: int,
    board: BoardOptions,
    angle_connector_path: str,
) -> tuple[str, str]:
    if count <= 0:
        return "", "    // no right-angle connectors requested"
    rows_of_snaps = (snap_total + per_row - 1) // per_row
    base_y = rows_of_snaps * spacing + spacing
    module_lines = [
        "module og_corner_connector() {",
        f"  import(\"{angle_connector_path}\");",
        "}\n",
    ]
    lines: list[str] = []
    for idx in range(count):
        row = idx // per_row
        col = idx % per_row
        x = col * spacing
        y = base_y + row * spacing
        lines.append(f"    translate([{x:.3f}, {y:.3f}, 0]) og_corner_connector();")
    return "\n".join(module_lines), "\n".join(lines)


def _imported_angle_connectors(
    board: BoardOptions, panel_set: OpenGridPanelSet, label: str, include_preview_imports: bool
) -> str:
    # Disabled for now – the OpenGrid angle STL breaks OpenSCAD's CSG export and slows down STEP conversion.
    return "\n"
    if label != "assembled" or not include_preview_imports:
        return "\n"
    length = panel_set.length_mm
    width = panel_set.width_mm
    height = panel_set.height_mm + board.thickness_mm
    entries = []
    stl_path = board.angle_connector_path if hasattr(board, "angle_connector_path") else ""
    if not stl_path:
        return "\n"
    # Long sides (±X), connectors centered, pointing inward
    entries.append(
        f"\n    translate([0, {width/2 + board.thickness_mm:.3f}, {height:.3f}]) rotate([0,180,0]) import(\"{stl_path}\");"
    )
    entries.append(
        f"\n    translate([0, {-width/2 - board.thickness_mm:.3f}, {height:.3f}]) rotate([180,0,180]) import(\"{stl_path}\");"
    )
    # Short sides (±Y)
    entries.append(
        f"\n    translate([{length/2 + board.thickness_mm:.3f}, 0, {height:.3f}]) rotate([0,180,90]) import(\"{stl_path}\");"
    )
    entries.append(
        f"\n    translate([{-length/2 - board.thickness_mm:.3f}, 0, {height:.3f}]) rotate([180,0,90]) import(\"{stl_path}\");"
    )
    return "\n" + "".join(entries) + "\n"
