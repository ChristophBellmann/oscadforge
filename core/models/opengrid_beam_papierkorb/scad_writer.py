from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
import colorsys
import re
from typing import Iterable, Mapping, Sequence, Set

from ..papierkorb.layout import PanelPlacement
from ..papierkorb.panels import AxisDirection, Panel, PanelFeature, PanelKind
from .connectors import ConnectorPlan
from .panels import OpenGridPanelSet
from .params import BoardOptions, ConnectorOptions


EPS = 1.0e-6

PALETTE = [
    (0.88, 0.40, 0.36),
    (0.25, 0.55, 0.78),
    (0.32, 0.70, 0.48),
    (0.85, 0.65, 0.25),
    (0.60, 0.45, 0.80),
    (0.90, 0.55, 0.75),
    (0.40, 0.75, 0.85),
    (0.55, 0.65, 0.30),
    (0.75, 0.35, 0.60),
    (0.30, 0.60, 0.55),
    (0.85, 0.45, 0.30),
    (0.40, 0.50, 0.80),
]


@dataclass
class IncludePaths:
    bosl2: str
    open_grid: str
    open_grid_beam: str
    snap: str
    angle_connector: str


class BeamPlacementMode(Enum):
    PANEL_ONLY = "panel"
    BEAM_ONLY = "beam"
    BOTH = "both"


@dataclass(frozen=True)
class BeamCallConfig:
    enable_beam_sides: bool = True
    enable_chamfers: bool = True
    enable_joints: bool = True
    side_overrides: Mapping[str, bool] | None = None


def build_scad_for_artifact(
    *,
    artifact_label: str,
    placements: Iterable[PanelPlacement],
    panel_set: OpenGridPanelSet,
    board: BoardOptions,
    connectors: ConnectorPlan | None,
    connector_opts: ConnectorOptions | None,
    includes: IncludePaths,
    include_preview_imports: bool = True,
    beam_mode: BeamPlacementMode = BeamPlacementMode.PANEL_ONLY,
) -> str:
    header = _build_header(includes, board)
    if artifact_label == "connectors":
        body = _connectors_body(connectors, board, connector_opts, includes.angle_connector)
        return f"{header}\n{body}\nconnectors_artifact();\n"
    panel_modules = _panel_modules(panel_set, board)
    color_defs, color_map = _build_panel_color_modules(panel_set)
    placement_block = _placement_block(
        artifact_label,
        placements,
        board.tile_size_mm,
        board,
        panel_set,
        include_preview_imports=include_preview_imports,
        beam_mode=beam_mode,
        color_map=color_map,
    )
    sections = [header]
    if panel_modules:
        sections.append(panel_modules)
    if color_defs:
        sections.append(color_defs)
    sections.append(placement_block)
    sections.append(f"artifact_{artifact_label}();")
    return "\n\n".join(sections) + "\n"


def build_scad_for_panel(
    *,
    panel: Panel,
    board: BoardOptions,
    includes: IncludePaths,
) -> str:
    header = _build_header(includes, board)
    module = _panel_module(panel, board)
    return f"{header}\n{module}\npanel_geom_{panel.panel_id}();\n"


def _build_header(includes: IncludePaths, board: BoardOptions) -> str:
    variant = board.variant.strip()
    screw = board.screw_mounting.strip()
    return (
        f"// Generated by oscadforge opengrid-beam_papierkorb backend\n"
        f'include <{includes.bosl2}>;\n'
        f'use <{includes.open_grid}>;\n'
        f'use <{includes.open_grid_beam}>;\n'
        f'use <{includes.snap}>;\n'
        f'Full_or_Lite = "{variant}";\n'
        'Chamfers = "Corners";\n'
        f'Screw_Mounting = "{screw}";\n'
        "Connector_Holes = true;\n"
        "Connector_Holes_Bottom = true;\n"
        "Connector_Holes_Top = true;\n"
        "Connector_Holes_Left = true;\n"
        "Connector_Holes_Right = true;\n"
        "Boardconnector_Bottom_l = true;\n"
        "Boardconnector_Bottom_r = true;\n"
        "Boardconnector_Left_l = true;\n"
        "Boardconnector_Left_r = true;\n"
        "Boardconnector_Top_l = true;\n"
        "Boardconnector_Top_r = true;\n"
        "Boardconnector_Right_l = true;\n"
        "Boardconnector_Right_r = true;\n"
        "Add_Adhesive_Base = false;\n"
    )


def _panel_modules(panel_set: OpenGridPanelSet, board: BoardOptions) -> str:
    modules = []
    central_ids = _central_floor_panel_ids(panel_set)
    side_contacts = _build_side_contacts(panel_set.panels)
    for panel in panel_set.panels:
        modules.append(_panel_module(panel, board))
        config = _beam_config_for_panel(panel, central_ids, side_contacts)
        modules.append(_beam_module(panel, board, config))
    return "\n".join(modules)


def _panel_module(panel: Panel, board: BoardOptions) -> str:
    cells_u = max(1, int(round(panel.width / board.tile_size_mm)))
    cells_v = max(1, int(round(panel.height / board.tile_size_mm)))
    thickness = board.thickness_mm
    call = _board_call(cells_u, cells_v, thickness, board)
    return f"module panel_geom_{panel.panel_id}() {{\n    {call}\n}}\n"


def _beam_module(panel: Panel, board: BoardOptions, config: BeamCallConfig) -> str:
    cells_u = max(1, int(round(panel.width / board.tile_size_mm)))
    cells_v = max(1, int(round(panel.height / board.tile_size_mm)))
    thickness = board.thickness_mm
    call = _beam_call(cells_u, cells_v, thickness, board, config)
    beam_id = _beam_panel_id(panel.panel_id)
    return f"module panel_geom_{beam_id}() {{\n{call}\n}}\n"


def _beam_panel_id(panel_id: str) -> str:
    if "_" in panel_id:
        prefix, rest = panel_id.split("_", 1)
        return f"{prefix}beam_{rest}"
    return f"{panel_id}beam"


def _beam_call(cells_u: int, cells_v: int, thickness: float, board: BoardOptions, config: BeamCallConfig) -> str:
    bool_val = lambda val: "true" if val else "false"
    bottom_val = bool_val(_side_flag(config, "bottom"))
    left_val = bool_val(_side_flag(config, "left"))
    top_val = bool_val(_side_flag(config, "top"))
    right_val = bool_val(_side_flag(config, "right"))
    chamfer_val = bool_val(config.enable_chamfers)
    joint_val = bool_val(config.enable_joints)
    lines = [
        "    openGridbeam(",
        f"    Board_Width             = {cells_u},",
        f"    Board_Height            = {cells_v},",
        "",
        "    // Beam-Sides",
        f"    Beam_Bottom             = {bottom_val},",
        f"    Beam_Left               = {left_val},",
        f"    Beam_Top                = {top_val},",
        f"    Beam_Right              = {right_val},",
        "",
        "",
        "    // Beam Connector Options",
        "    Beamconnector_Bottom_l  = true,",
        "    Beamconnector_Bottom_r  = true,",
        "    Beamconnector_Left_l    = true,",
        "    Beamconnector_Left_r    = true,",
        "    Beamconnector_Top_l     = true,",
        "    Beamconnector_Top_r     = true,",
        "    Beamconnector_Right_l   = true,",
        "    Beamconnector_Right_r   = true,",
        "",
        "    // Beam Lenght Options",
        "    Beamlenght_shorten   = false,",
        "    Beamlenght_shorten_Bottom_l  = true,",
        "    Beamlenght_shorten_Bottom_r  = true,",
        "    Beamlenght_shorten_Left_l    = true,",
        "    Beamlenght_shorten_Left_r    = true,",
        "    Beamlenght_shorten_Top_l     = true,",
        "    Beamlenght_shorten_Top_r     = true,",
        "    Beamlenght_shorten_Right_l   = true,",
        "    Beamlenght_shorten_Right_r   = true,",
        "",
        "    // Joint Options",
        f"    Joints                  = {joint_val},",
        f"    Joint_Bottom_l          = {joint_val},",
        f"    Joint_Bottom_r          = {joint_val},",
        f"    Joint_Left_l            = {joint_val},",
        f"    Joint_Left_r            = {joint_val},",
        f"    Joint_Top_l             = {joint_val},",
        f"    Joint_Top_r             = {joint_val},",
        f"    Joint_Right_l           = {joint_val},",
        f"    Joint_Right_r           = {joint_val},",
        "",
        "    // Attached Option",
        "    Joint_attached          = false,",
        "",
        "    // Chamfer Options",
        f"    Chamfers                = {chamfer_val},",
        f"    Chamfer_Bottom_l        = {chamfer_val},",
        f"    Chamfer_Bottom_r        = {chamfer_val},",
        f"    Chamfer_Left_l          = {chamfer_val},",
        f"    Chamfer_Left_r          = {chamfer_val},",
        f"    Chamfer_Top_l           = {chamfer_val},",
        f"    Chamfer_Top_r           = {chamfer_val},",
        f"    Chamfer_Right_l         = {chamfer_val},",
        f"    Chamfer_Right_r         = {chamfer_val},",
        "",
        "    // OpenSCAD Transform Parameters",
        "    anchor                  = CENTER,",
        "    spin                    = 0,",
        "    orient                  = UP",
        "    );",
    ]
    return "\n".join(lines)


def _side_flag(config: BeamCallConfig, side: str) -> bool:
    overrides = config.side_overrides or {}
    if side in overrides:
        return overrides[side]
    return config.enable_beam_sides


def _build_panel_color_modules(panel_set: OpenGridPanelSet) -> tuple[str, dict[str, str]]:
    panels = sorted(panel_set.panels, key=lambda panel: panel.panel_id)
    if not panels:
        return "", {}
    modules: list[str] = []
    mapping: dict[str, str] = {}
    total = len(panels)
    for idx, panel in enumerate(panels):
        module_name = f"panel_color_{_sanitize_id(panel.panel_id)}"
        mapping[panel.panel_id] = module_name
        r, g, b = _rainbow_color(idx, total)
        modules.append(
            f"module {module_name}() {{\n"
            f"  color([{r:.3f}, {g:.3f}, {b:.3f}]) children();\n"
            f"}}"
        )
    return "\n\n".join(modules), mapping


def _sanitize_id(value: str) -> str:
    cleaned = re.sub(r"[^A-Za-z0-9_]", "_", value)
    if not cleaned:
        return "panel"
    return cleaned if not cleaned[0].isdigit() else f"_{cleaned}"


def _rainbow_color(index: int, total: int) -> tuple[float, float, float]:
    if total <= 0:
        return 0.5, 0.5, 0.5
    hue = (index / total) % 1.0
    r, g, b = colorsys.hsv_to_rgb(hue, 0.75, 0.95)
    return r, g, b


def _beam_config_for_panel(
    panel: Panel,
    central_ids: set[str],
    side_contacts: Mapping[str, Set[str]],
) -> BeamCallConfig:
    if panel.panel_id in central_ids:
        return BeamCallConfig(enable_beam_sides=False, enable_chamfers=False, enable_joints=False)
    overrides = {side: False for side in side_contacts.get(panel.panel_id, set())}
    return BeamCallConfig(side_overrides=overrides or None)


def _central_floor_panel_ids(panel_set: OpenGridPanelSet) -> set[str]:
    lookup: dict[tuple[int, int], str] = {}
    for panel in panel_set.panels:
        if panel.kind is PanelKind.FLOOR:
            ix, iy, _ = panel.indices
            lookup[(ix, iy)] = panel.panel_id
    central: set[str] = set()
    for (ix, iy), panel_id in lookup.items():
        neighbors = [
            (ix - 1, iy),
            (ix + 1, iy),
            (ix, iy - 1),
            (ix, iy + 1),
        ]
        has_horizontal = (ix - 1, iy) in lookup and (ix + 1, iy) in lookup
        has_vertical = (ix, iy - 1) in lookup and (ix, iy + 1) in lookup
        if all(nb in lookup for nb in neighbors) or has_horizontal or has_vertical:
            central.add(panel_id)
    return central


def _board_call(cells_u: int, cells_v: int, thickness: float, board: BoardOptions) -> str:
    base_args = (
        f"Board_Width={cells_u}, "
        f"Board_Height={cells_v}, "
        f'Screw_Mounting="{board.screw_mounting}"'
    )
    suffix = "anchor=CENTER, spin=0, orient=UP"
    if board.variant.strip().lower() == "lite":
        return f"openGridLite({base_args}, {suffix});"
    if board.variant.strip().lower() == "heavy":
        return f"openGridHeavy({base_args}, {suffix});"
    return f"openGrid({base_args}, Tile_Thickness={thickness:.4f}, {suffix});"


def _placement_block(
    label: str,
    placements: Iterable[PanelPlacement],
    tile_size: float,
    board: BoardOptions,
    panel_set: OpenGridPanelSet,
    include_preview_imports: bool = True,
    beam_mode: BeamPlacementMode = BeamPlacementMode.PANEL_ONLY,
    color_map: Mapping[str, str] | None = None,
) -> str:
    color_map = color_map or {}
    statements = []
    for placement in placements:
        matrix = placement_matrix(placement)
        transform = _format_matrix(matrix)
        module_names: list[str] = []
        if beam_mode in (BeamPlacementMode.PANEL_ONLY, BeamPlacementMode.BOTH):
            module_names.append(placement.panel.panel_id)
        if beam_mode in (BeamPlacementMode.BEAM_ONLY, BeamPlacementMode.BOTH):
            module_names.append(_beam_panel_id(placement.panel.panel_id))
        for module_id in module_names:
            col_module = color_map.get(placement.panel.panel_id)
            if col_module:
                statements.append(
                    f"    {col_module}() {{\n"
                    f"      multmatrix({transform}) panel_geom_{module_id}();\n"
                    f"    }}"
                )
            else:
                colour = _panel_colour(placement.panel.panel_id)
                statements.append(f"    {colour} multmatrix({transform}) panel_geom_{module_id}();")
    body = "\n".join(statements) if statements else "    // no panels"
    accessories = _imported_angle_connectors(board, panel_set, label, include_preview_imports)
    return f"module artifact_{label}() {{\n  union() {{\n{body}{accessories}\n  }}\n}}\n"


def placement_matrix(placement: PanelPlacement) -> list[list[float]]:
    origin = placement.origin
    u_vec = placement.axes.u.vector()
    v_vec = placement.axes.v.vector()
    w_vec = placement.axes.w.vector()
    return [
        [u_vec.x, v_vec.x, w_vec.x, origin.x],
        [u_vec.y, v_vec.y, w_vec.y, origin.y],
        [u_vec.z, v_vec.z, w_vec.z, origin.z],
        [0.0, 0.0, 0.0, 1.0],
    ]


def _format_matrix(matrix: Sequence[Sequence[float]]) -> str:
    rows = ["[{}]".format(", ".join(f"{value:.6f}" for value in row)) for row in matrix]
    return f"[{', '.join(rows)}]"


def _panel_colour(panel_id: str) -> str:
    seed = sum(panel_id.encode("utf-8"))
    r, g, b = PALETTE[seed % len(PALETTE)]
    return f"color([{r:.3f}, {g:.3f}, {b:.3f}])"


def _build_side_contacts(panels: Sequence[Panel]) -> dict[str, Set[str]]:
    contacts: dict[str, Set[str]] = {}
    for panel in panels:
        contacts[panel.panel_id] = _panel_side_neighbors(panel, panels)
    return contacts


def _panel_side_neighbors(panel: Panel, panels: Sequence[Panel]) -> Set[str]:
    sides: Set[str] = set()
    for other in panels:
        if other is panel:
            continue
        for side_name, axis_lab, direction in _side_specs(panel.axes):
            if _touches_on_axis(panel, other, axis_lab, direction):
                sides.add(side_name)
    return sides


def _side_specs(axes: PanelAxes) -> list[tuple[str, str, int]]:
    return [
        ("right", axes.u.axis, axes.u.sign),
        ("left", axes.u.axis, -axes.u.sign),
        ("top", axes.v.axis, axes.v.sign),
        ("bottom", axes.v.axis, -axes.v.sign),
    ]


def _touches_on_axis(panel: Panel, other: Panel, axis: str, direction: int) -> bool:
    panel_min, panel_max = _axis_range(panel.bounds, axis)
    other_min, other_max = _axis_range(other.bounds, axis)
    boundary = panel_max if direction > 0 else panel_min
    target = other_min if direction > 0 else other_max
    if abs(boundary - target) > EPS:
        return False
    for orth in _AXIS_OTHER[axis]:
        a_min, a_max = _axis_range(panel.bounds, orth)
        b_min, b_max = _axis_range(other.bounds, orth)
        if not _intervals_overlap(a_min, a_max, b_min, b_max):
            return False
    return True


_AXIS_OTHER = {"x": ("y", "z"), "y": ("x", "z"), "z": ("x", "y")}


def _axis_range(bounds: tuple[float, float, float, float, float, float], axis: str) -> tuple[float, float]:
    idx = {"x": 0, "y": 2, "z": 4}[axis]
    return bounds[idx], bounds[idx + 1]


def _intervals_overlap(a_min: float, a_max: float, b_min: float, b_max: float) -> bool:
    return min(a_max, b_max) - max(a_min, b_min) > EPS


def _connectors_body(
    plan: ConnectorPlan | None,
    board: BoardOptions,
    connector_opts: ConnectorOptions | None,
    angle_connector_path: str,
) -> str:
    if plan is None:
        plan = ConnectorPlan(snap_count=0, corner_count=0)
    if connector_opts is None:
        connector_opts = ConnectorOptions()
    spacing = board.tile_size_mm + 6.0
    per_row = 8
    snap_lines = _replicated_snap_block(plan.snap_count, spacing, per_row, connector_opts)
    corner_module, corner_lines = _replicated_corner_block(
        plan.corner_count,
        spacing,
        per_row,
        plan.snap_count,
        board,
        angle_connector_path,
    )
    header = corner_module if corner_module else ""
    return (
        f"{header}"
        "module connectors_artifact() {\n"
        "  union() {\n"
        f"{snap_lines}\n"
        f"{corner_lines}\n"
        "  }\n"
        "}\n"
    )


def _replicated_snap_block(count: int, spacing: float, per_row: int, connector_opts: ConnectorOptions) -> str:
    if count <= 0:
        return "    // no snap connectors requested"
    bool_val = lambda val: "true" if val else "false"
    lite_mode = connector_opts.snap_variant.strip().lower() != "full"
    lines = []
    for idx in range(count):
        row = idx // per_row
        col = idx % per_row
        x = col * spacing
        y = row * spacing
        lines.append(
            f"    translate([{x:.3f}, {y:.3f}, 0]) openGridSnap(lite={bool_val(lite_mode)}, directional={bool_val(connector_opts.directional_snaps)}, orient=UP, anchor=CENTER, spin=0);"
        )
    return "\n".join(lines)


def _replicated_corner_block(
    count: int,
    spacing: float,
    per_row: int,
    snap_total: int,
    board: BoardOptions,
    angle_connector_path: str,
) -> tuple[str, str]:
    if count <= 0:
        return "", "    // no right-angle connectors requested"
    rows_of_snaps = (snap_total + per_row - 1) // per_row
    base_y = rows_of_snaps * spacing + spacing
    module_lines = [
        "module og_corner_connector() {",
        f"  import(\"{angle_connector_path}\");",
        "}\n",
    ]
    lines: list[str] = []
    for idx in range(count):
        row = idx // per_row
        col = idx % per_row
        x = col * spacing
        y = base_y + row * spacing
        lines.append(f"    translate([{x:.3f}, {y:.3f}, 0]) og_corner_connector();")
    return "\n".join(module_lines), "\n".join(lines)


def _imported_angle_connectors(
    board: BoardOptions, panel_set: OpenGridPanelSet, label: str, include_preview_imports: bool
) -> str:
    # Disabled for now – the OpenGrid angle STL breaks OpenSCAD's CSG export and slows down STEP conversion.
    return "\n"
    if label != "assembled" or not include_preview_imports:
        return "\n"
    length = panel_set.length_mm
    width = panel_set.width_mm
    height = panel_set.height_mm + board.thickness_mm
    entries = []
    stl_path = board.angle_connector_path if hasattr(board, "angle_connector_path") else ""
    if not stl_path:
        return "\n"
    # Long sides (±X), connectors centered, pointing inward
    entries.append(
        f"\n    translate([0, {width/2 + board.thickness_mm:.3f}, {height:.3f}]) rotate([0,180,0]) import(\"{stl_path}\");"
    )
    entries.append(
        f"\n    translate([0, {-width/2 - board.thickness_mm:.3f}, {height:.3f}]) rotate([180,0,180]) import(\"{stl_path}\");"
    )
    # Short sides (±Y)
    entries.append(
        f"\n    translate([{length/2 + board.thickness_mm:.3f}, 0, {height:.3f}]) rotate([0,180,90]) import(\"{stl_path}\");"
    )
    entries.append(
        f"\n    translate([{-length/2 - board.thickness_mm:.3f}, 0, {height:.3f}]) rotate([180,0,90]) import(\"{stl_path}\");"
    )
    return "\n" + "".join(entries) + "\n"
