from __future__ import annotations

from dataclasses import dataclass, fields
from pathlib import Path
from typing import Any, Mapping, Sequence
import textwrap

from ...core.engine import BuildContext, EngineResult
from ...core.export import ExportError, build_png_args, export_step_artifact, run_openscad

REPO_ROOT = next(p for p in Path(__file__).resolve().parents if p.name == "oscadforge").parent
# Prefer user-provided SCAD under in/openGrid-beam
BEAM_SCAD_PATH = REPO_ROOT / "in" / "openGrid-beam" / "openGrid-beam.scad"


def _bool(value: bool) -> str:
    return "true" if value else "false"


@dataclass
class BeamJointParams:
    board_variant: str = "Full"  # Full, Lite, Heavy
    board_width: int = 6
    board_height: int = 6

    beam_segments: bool = True
    beam_bottom: bool = False
    beam_right: bool = False
    beam_left: bool = False
    beam_top: bool = True
    beam_extension: float = 0.5
    # Board connector cutouts (disable to avoid tile face showing)
    boardconnector_cutouts: bool = False
    boardconnector_bottom_l: bool = False
    boardconnector_bottom_r: bool = False
    boardconnector_left_l: bool = False
    boardconnector_left_r: bool = False
    boardconnector_top_l: bool = False
    boardconnector_top_r: bool = False
    boardconnector_right_l: bool = False
    boardconnector_right_r: bool = False

    beamconnector_cutouts: bool = True
    beamconnector_bottom_l: bool = True
    beamconnector_bottom_r: bool = True
    beamconnector_left_l: bool = True
    beamconnector_left_r: bool = True
    beamconnector_top_l: bool = True
    beamconnector_top_r: bool = True
    beamconnector_right_l: bool = True
    beamconnector_right_r: bool = True

    joints_enabled: bool = True
    joint_bottom_l: bool = False
    joint_bottom_r: bool = False
    joint_left_l: bool = False
    joint_left_r: bool = False
    joint_top_l: bool = False
    joint_top_r: bool = False
    joint_right_l: bool = False
    joint_right_r: bool = False

    joint_attached: bool = True
    joint_bottom_mirror: bool = False
    joint_top_mirror: bool = False
    joint_left_mirror: bool = False
    joint_right_mirror: bool = False

    joint_rotate_90: bool = False

    chamfers: bool = False
    chamfer_bottom_l: bool = True
    chamfer_bottom_r: bool = True
    chamfer_left_l: bool = True
    chamfer_left_r: bool = True
    chamfer_top_l: bool = True
    chamfer_top_r: bool = True
    chamfer_right_l: bool = True
    chamfer_right_r: bool = True

    tile_size_mm: float = 28.0
    tile_thickness_mm: float = 6.8
    lite_tile_thickness_mm: float = 4.0
    heavy_tile_thickness_mm: float = 13.8

    connector_cutout_radius: float = 2.6
    connector_cutout_dimple_radius: float = 2.7
    connector_cutout_separation: float = 2.5
    connector_cutout_height: float = 2.4
    lite_cutout_distance_from_top: float = 1.0

    connector_tolerance: float = 0.05
    connector_protrusion: float = 2.0

    intersection_distance: float = 4.2
    use_beam_transform: bool = True

    @classmethod
    def from_mapping(cls, data: Mapping[str, Any]) -> "BeamJointParams":
        kwargs = {}
        for field in fields(cls):
            if field.name in data:
                kwargs[field.name] = data[field.name]
        return cls(**kwargs)

    def validate(self) -> None:
        variants = {"Full", "Lite", "Heavy"}
        if self.board_variant not in variants:
            raise ValueError(f"board_variant must be one of {variants}")
        if self.board_width < 1 or self.board_height < 1:
            raise ValueError("board_width and board_height must be >= 1")


def _render_scad(params: BeamJointParams, *, call_scene: bool = True, include_prelude: bool = True) -> str:
    include_path = BEAM_SCAD_PATH.resolve()
    prelude = f"// Generated by oscadforge openGrid-beam model\ninclude <{include_path}>;\n\n" if include_prelude else "// Generated by oscadforge openGrid-beam model\n\n"
    # Include the SCAD and override the globals that steer the generator.
    body = textwrap.dedent(
        f"""
        {prelude}
        Full_or_Lite = "{params.board_variant}";
        Board_Width = {params.board_width};
        Board_Height = {params.board_height};

        Beam_Segments = {_bool(params.beam_segments)};
        Beam_Bottom   = {_bool(params.beam_bottom)};
        Beam_Right    = {_bool(params.beam_right)};
        Beam_Left     = {_bool(params.beam_left)};
        Beam_Top      = {_bool(params.beam_top)};
        Beam_Extension = {params.beam_extension};

        Boardconnector_cutouts = {_bool(params.boardconnector_cutouts)};
        Boardconnector_Bottom_l = {_bool(params.boardconnector_bottom_l)};
        Boardconnector_Bottom_r = {_bool(params.boardconnector_bottom_r)};
        Boardconnector_Left_l = {_bool(params.boardconnector_left_l)};
        Boardconnector_Left_r = {_bool(params.boardconnector_left_r)};
        Boardconnector_Top_l = {_bool(params.boardconnector_top_l)};
        Boardconnector_Top_r = {_bool(params.boardconnector_top_r)};
        Boardconnector_Right_l = {_bool(params.boardconnector_right_l)};
        Boardconnector_Right_r = {_bool(params.boardconnector_right_r)};

        Beamconnector_cutouts = {_bool(params.beamconnector_cutouts)};
        Beamconnector_Bottom_l = {_bool(params.beamconnector_bottom_l)};
        Beamconnector_Bottom_r = {_bool(params.beamconnector_bottom_r)};
        Beamconnector_Left_l = {_bool(params.beamconnector_left_l)};
        Beamconnector_Left_r = {_bool(params.beamconnector_left_r)};
        Beamconnector_Top_l = {_bool(params.beamconnector_top_l)};
        Beamconnector_Top_r = {_bool(params.beamconnector_top_r)};
        Beamconnector_Right_l = {_bool(params.beamconnector_right_l)};
        Beamconnector_Right_r = {_bool(params.beamconnector_right_r)};

        Joints = {_bool(params.joints_enabled)};

        Joint_Bottom_l    = {_bool(params.joint_bottom_l)};
        Joint_Bottom_r    = {_bool(params.joint_bottom_r)};
        Joint_Left_l      = {_bool(params.joint_left_l)};
        Joint_Left_r      = {_bool(params.joint_left_r)};
        Joint_Top_l       = {_bool(params.joint_top_l)};
        Joint_Top_r       = {_bool(params.joint_top_r)};
        Joint_Right_l     = {_bool(params.joint_right_l)};
        Joint_Right_r     = {_bool(params.joint_right_r)};
        Joint_attached    = {_bool(params.joint_attached)};
        Joint_Bottom_Mirror = {_bool(params.joint_bottom_mirror)};
        Joint_Top_Mirror    = {_bool(params.joint_top_mirror)};
        Joint_Left_Mirror   = {_bool(params.joint_left_mirror)};
        Joint_Right_Mirror  = {_bool(params.joint_right_mirror)};
        Joint_Rotate_90 = {_bool(params.joint_rotate_90)};

        Chamfers = {_bool(params.chamfers)};
        Chamfer_Bottom_l = {_bool(params.chamfer_bottom_l)};
        Chamfer_Bottom_r = {_bool(params.chamfer_bottom_r)};
        Chamfer_Left_l = {_bool(params.chamfer_left_l)};
        Chamfer_Left_r = {_bool(params.chamfer_left_r)};
        Chamfer_Top_l = {_bool(params.chamfer_top_l)};
        Chamfer_Top_r = {_bool(params.chamfer_top_r)};
        Chamfer_Right_l = {_bool(params.chamfer_right_l)};
        Chamfer_Right_r = {_bool(params.chamfer_right_r)};

        Tile_Size = {params.tile_size_mm};
        Tile_Thickness = {params.tile_thickness_mm};
        Lite_Tile_Thickness = {params.lite_tile_thickness_mm};
        Heavy_Tile_Thickness = {params.heavy_tile_thickness_mm};

        connector_cutout_radius        = {params.connector_cutout_radius};
        connector_cutout_dimple_radius = {params.connector_cutout_dimple_radius};
        connector_cutout_separation    = {params.connector_cutout_separation};
        connector_cutout_height        = {params.connector_cutout_height};
        lite_cutout_distance_from_top  = {params.lite_cutout_distance_from_top};

        Connector_Tolerance  = {params.connector_tolerance};
        Connector_Protrusion = {params.connector_protrusion};

        // Derived values (mirrors the source file)
        th =
            Full_or_Lite == "Lite"  ? Lite_Tile_Thickness :
            Full_or_Lite == "Heavy" ? Heavy_Tile_Thickness :
            Tile_Thickness;
        connector_length_half   = 5.1;
        Intersection_Distance   = {params.intersection_distance};
        d       = Intersection_Distance;
        leg_len = th + connector_length_half;

        back_offset = th / sqrt(2);
        front_offset = connector_length_half / sqrt(2);

        BASE_TILE_SIZE = Tile_Size;
        tile_size = BASE_TILE_SIZE;

        extension    = tile_size / 2 - Intersection_Distance;
        Joint_Length = Intersection_Distance;

        use_beam_transform = {_bool(params.use_beam_transform)};
        """
    ).strip()
    if call_scene:
        body += "\n\nscene(Board_Width=Board_Width, Board_Height=Board_Height);\n"
    return body + "\n"


def _png_args_from_cfg(cfg: Mapping[str, Any] | bool | None) -> tuple[bool, Sequence[str]]:
    enabled, base_args = build_png_args(cfg)
    return enabled, base_args


def build(context: BuildContext) -> EngineResult:
    params = BeamJointParams.from_mapping(context.model_params)
    params.validate()

    if not BEAM_SCAD_PATH.exists():
        raise FileNotFoundError(
            f"beam_and_joint.scad not found at {BEAM_SCAD_PATH}; "
            "place the file under third_party/Opengrid-Beam/."
        )

    scad_text = _render_scad(params)
    scad_path = context.out_dir / f"{context.basename}.scad"
    scad_path.write_text(scad_text, encoding="utf-8")

    logs: list[str] = [f"SCAD written to {scad_path}"]
    stl_paths: list[Path] = []
    step_paths: list[Path] = []
    png_paths: list[Path] = []

    if context.export.get("stl"):
        stl_path = context.out_dir / f"{context.basename}.stl"
        run_openscad(scad_path, stl_path, context.openscad_bin)
        stl_paths.append(stl_path)
        logs.append(f"STL written to {stl_path}")

    if context.export.get("step"):
        step_path = context.out_dir / f"{context.basename}.step"
        step_result = export_step_artifact(
            scad_path,
            step_path,
            export_cfg=context.export,
            openscad_bin=context.openscad_bin,
            freecad_bin=context.freecad_bin,
            stl_path=stl_paths[-1] if stl_paths else None,
        )
        step_paths.append(step_result.step_path)
        if step_result.dedup_hit and step_result.cache_path:
            logs.append(
                f"STEP linked to cached geometry {step_result.cache_path} -> {step_result.step_path}"
            )
        else:
            logs.append(f"STEP written to {step_result.step_path}")

    png_enabled, png_args = _png_args_from_cfg(context.export.get("png"))
    if png_enabled:
        png_path = context.out_dir / f"{context.basename}.png"
        try:
            run_openscad(scad_path, png_path, context.openscad_bin, png_args)
        except ExportError as exc:
            logs.append(f"PNG export failed via OpenSCAD ({exc})")
        else:
            png_paths.append(png_path)
            logs.append(f"PNG written to {png_path}")

    metadata = {
        "board_width": params.board_width,
        "board_height": params.board_height,
        "board_variant": params.board_variant,
    }
    return EngineResult(
        scad_path=scad_path,
        stl_paths=stl_paths,
        step_paths=step_paths,
        png_paths=png_paths,
        logs=logs,
        metadata=metadata,
    )
